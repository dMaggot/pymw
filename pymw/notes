Notes for PyMW:

The goal of this project is to provide a generalized Python interface
for master-worker style computation.  Regardless of the underlying
platform, a few simple commands should allow for execution of any
Python script on any infrastructure (multicore, cluster, Grid, etc).

A diagram of the levels of abstraction is shown below:

-------------
    User
-------------
    PyMW
-------------
  Interface
-------------
Process, rsh,
SCore, Grid,
BOINC, etc
-------------

Current user commands to PyMW:
	pymw_master = PyMW_Master(interface, use_state_records=False)
	task = submit_task(name, executable, input_data)
		Creates a task, submits it to the interface,
		and returns a Task object to the user.
	
	output = wait_for_task_finish(task)
		Waits for the task to finish execution, then
		returns the result to the user.

PyMW Internals:
	Upon initialization, PyMW creates a scheduler thread.
	This thread waits for an available worker (from
	reserve_worker()), then executes the task on the worker
	with execute_task().
	
Current interface functions:
	interface = Interface(record_state=False)
		Returns a new interface object that supports the
		following functions. If record_state is True, this
		object should save/restore the state of workers and
		tasks to allow for program resumption.

	worker = reserve_worker()
		Return an object representing a worker that can
		execute a task. The internals of the worker object
		are specific to each interface, and are ignored by PyMW.
		If the worker need not be specified, interfaces may
		return None.  This is implemented mainly to avoid
		resource overuse (e.g. running 1000 tasks simultaneously
		on 1 CPU), and should allow in the future for task-worker
		specific matching.
		
	execute_task(task, worker)
		Executes the task on the worker.  This is executed in a
		thread by PyMW, so does not need to return asynchronously.
		The input data for the task is a pickled object generated
		by PyMW, located at task.input_arg.  The output data will
		be a pickled object generated by the worker program.

    cleanup()
    	Cleans up the interface and related files.
    
	get_status()
		Returns a dictionary with interface specific status.

Interface Requirements:
	Interface must provide reserve_worker, execute_task functions.
	Execute task must asynchronously execute the task given to it.
	Once task execution is complete, task.task_finished() must be
	called.

Notes for BOINC Interface:

The client application consists of two files: a script/batch file,
that calls the Python interpreter with the worker module and
the app_types module. Both files are registered with the copy_file
option, since PyMW does not utilize the filename resolution 
functionality of BOINC, yet.

TODO:
	- More carefully define what happens when multiple calls to pymw_return_output are made
	- Finish state saving functionality, test
	- Implement MPI interface
	- Allow functions to be passed as the worker
	- Allow for passing of object files to worker through stdin
	