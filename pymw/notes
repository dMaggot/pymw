Notes for PyMW:

The goal of this project is to provide a generalized Python interface
for master-worker style computation.  Regardless of the underlying
platform, a few simple commands should allow for execution of any
Python script on any infrastructure (multicore, cluster, Grid, etc).

A diagram of the levels of abstraction is shown below:

-------------
    User
-------------
    PyMW
-------------
  Interface
-------------
Process, rsh,
SCore, Grid,
BOINC, etc
-------------

Current user commands to PyMW:
	pymw_master = PyMW_Master(interface)
		Creates a PyMW_Master which receives tasks
		to be executed.
	
	task = submit_task(name, executable, input_data=None,
						modules=(), dep_funcs=())
		Creates a task, submits it to the interface,
		and returns a Task object to the user.
		executable can be the name of a Python script or a
		Python function currently in the namespace.  If
		executable is a function, modules and dep_funcs indicate
		the modules and other functions needed.
	
	result_task, result_data = get_result(task=None, blocking=True)
		Gets the result of the executed task.
        If task is None, return the result of the next finished task.
        If blocking is false and the task is not finished, returns None.

PyMW Internals:
	Upon task submission, PyMW creates a scheduler thread if none
	is running.  This thread waits for an available worker (from
	reserve_worker()), then executes the task on the worker with
	execute_task().  The scheduler exits when it has no more tasks
	to execute.  This is to avoid hanging Python programs.
	
Current interface functions:
	interface = Interface()
		Returns a new interface object that supports the
		following functions.

	worker = reserve_worker()
		Return an object representing a worker that can
		execute a task. The internals of the worker object
		are specific to each interface, and are ignored by PyMW.
		If the worker need not be specified, interfaces may
		return None.  This is implemented mainly to avoid
		resource overuse (e.g. running 1000 tasks simultaneously
		on 1 CPU), and should allow in the future for task-worker
		specific matching.
		
	execute_task(task, worker)
		Executes the task on the worker.  This is executed in a
		thread by PyMW, so does not need to return asynchronously.
		The input data for the task is a pickled object generated
		by PyMW, located at task.input_arg.  The output data will
		be a pickled object generated by the worker program.

    _cleanup()
    	Cleans up the interface and related files.
    
	get_status()
		Returns a dictionary with interface specific status.

Interface Requirements:
	Interface must provide reserve_worker() and execute_task() functions.
	The _cleanup() and get_status() functions are optional.
	execute_task() may synchronously or asynchronously execute the task
	passed to it. Once task execution is complete, the interface must
	call task.task_finished().

Notes for BOINC Interface:

The client application consists of two files: a script/batch file,
that calls the Python interpreter with the worker module and
the app_types module. Both files are registered with the copy_file
option, since PyMW does not utilize the filename resolution 
functionality of BOINC, yet.
